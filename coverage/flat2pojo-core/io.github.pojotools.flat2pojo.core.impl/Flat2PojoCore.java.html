<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Flat2PojoCore.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">flat2pojo-coverage</a> &gt; <a href="../index.html" class="el_bundle">flat2pojo-core</a> &gt; <a href="index.source.html" class="el_package">io.github.pojotools.flat2pojo.core.impl</a> &gt; <span class="el_source">Flat2PojoCore.java</span></div><h1>Flat2PojoCore.java</h1><pre class="source lang-java linenums">package io.github.pojotools.flat2pojo.core.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import io.github.pojotools.flat2pojo.core.api.Flat2Pojo;
import io.github.pojotools.flat2pojo.core.config.ListHierarchyCache;
import io.github.pojotools.flat2pojo.core.config.MappingConfig;
import io.github.pojotools.flat2pojo.core.config.MappingConfigLoader;
import io.github.pojotools.flat2pojo.core.engine.ArrayManager;
import io.github.pojotools.flat2pojo.core.engine.PrimitiveArrayManager;
import io.github.pojotools.flat2pojo.core.engine.ValueTransformer;
import io.github.pojotools.flat2pojo.core.util.PathResolver;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Stream;

public final class Flat2PojoCore implements Flat2Pojo {
  private final ObjectMapper objectMapper;

<span class="fc" id="L22">  public Flat2PojoCore(ObjectMapper objectMapper) {</span>
<span class="fc" id="L23">    this.objectMapper = objectMapper;</span>
<span class="fc" id="L24">  }</span>

  @Override
  public &lt;T&gt; Optional&lt;T&gt; convertOptional(
      Map&lt;String, ?&gt; flatRow, Class&lt;T&gt; type, MappingConfig config) {
<span class="nc" id="L29">    List&lt;T&gt; all = convertAll(List.of(flatRow), type, config);</span>
<span class="nc bnc" id="L30" title="All 2 branches missed.">    return all.isEmpty() ? Optional.empty() : Optional.of(all.getFirst());</span>
  }

  /**
   * Converts flat key-value maps into structured POJOs using hierarchical list grouping.
   *
   * &lt;p&gt;Algorithm: Validate → Group by rootKeys → Process each group → Materialize to POJO
   *
   * @param rows flat key-value maps (e.g., from CSV, database JOIN results)
   * @param type target POJO class to convert to
   * @param config mapping configuration defining list rules, separators, conflict policies
   * @return list of structured POJOs, one per root group
   */
  @Override
  public &lt;T&gt; List&lt;T&gt; convertAll(
      final List&lt;? extends Map&lt;String, ?&gt;&gt; rows, final Class&lt;T&gt; type, final MappingConfig config) {
<span class="fc" id="L46">    MappingConfigLoader.validateHierarchy(config);</span>
<span class="fc" id="L47">    final ProcessingPipeline pipeline = buildProcessingPipeline(config);</span>

<span class="fc bfc" id="L49" title="All 2 branches covered.">    return config.rootKeys().isEmpty()</span>
<span class="fc" id="L50">        ? convertWithoutGrouping(rows, type, pipeline)</span>
<span class="fc" id="L51">        : convertWithGrouping(rows, type, config, pipeline);</span>
  }

  private ProcessingPipeline buildProcessingPipeline(final MappingConfig config) {
<span class="fc" id="L55">    final AssemblerDependencies dependencies = buildAssemblerDependencies(config);</span>
<span class="fc" id="L56">    final ProcessingContext context = buildProcessingContext(config);</span>
<span class="fc" id="L57">    return new ProcessingPipeline(dependencies, context);</span>
  }

  private ProcessingContext buildProcessingContext(final MappingConfig config) {
<span class="fc" id="L61">    final PathResolver pathResolver = new PathResolver(config.separator());</span>
<span class="fc" id="L62">    final ListHierarchyCache hierarchyCache = new ListHierarchyCache(config, pathResolver);</span>
<span class="fc" id="L63">    return new ProcessingContext(config, hierarchyCache, pathResolver);</span>
  }

  private AssemblerDependencies buildAssemblerDependencies(final MappingConfig config) {
<span class="fc" id="L67">    return AssemblerDependencies.builder()</span>
<span class="fc" id="L68">        .objectMapper(objectMapper)</span>
<span class="fc" id="L69">        .arrayManager(new ArrayManager(objectMapper, config))</span>
<span class="fc" id="L70">        .valueTransformer(new ValueTransformer(objectMapper, config))</span>
<span class="fc" id="L71">        .primitiveArrayManager(new PrimitiveArrayManager(objectMapper, config))</span>
<span class="fc" id="L72">        .materializer(new ResultMaterializer(objectMapper))</span>
<span class="fc" id="L73">        .build();</span>
  }

  private &lt;T&gt; List&lt;T&gt; convertWithoutGrouping(
      final List&lt;? extends Map&lt;String, ?&gt;&gt; rows,
      final Class&lt;T&gt; type,
      final ProcessingPipeline pipeline) {
<span class="fc" id="L80">    final RowProcessor processor = pipeline.createAssembler();</span>
<span class="fc" id="L81">    rows.forEach(processor::processRow);</span>
<span class="fc" id="L82">    return List.of(processor.materialize(type));</span>
  }

  private &lt;T&gt; List&lt;T&gt; convertWithGrouping(
      final List&lt;? extends Map&lt;String, ?&gt;&gt; rows,
      final Class&lt;T&gt; type,
      final MappingConfig config,
      final ProcessingPipeline pipeline) {
<span class="fc" id="L90">    final Map&lt;Object, List&lt;Map&lt;String, ?&gt;&gt;&gt; rowGroups =</span>
<span class="fc" id="L91">        RootKeyGrouper.groupByRootKeys(rows, config.rootKeys());</span>
<span class="fc" id="L92">    final List&lt;T&gt; results = new ArrayList&lt;&gt;(rowGroups.size());</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">    for (final List&lt;Map&lt;String, ?&gt;&gt; groupRows : rowGroups.values()) {</span>
<span class="fc" id="L94">      results.add(processGroup(groupRows, type, pipeline));</span>
<span class="fc" id="L95">    }</span>
<span class="fc" id="L96">    return results;</span>
  }

  private &lt;T&gt; T processGroup(
      final List&lt;Map&lt;String, ?&gt;&gt; groupRows,
      final Class&lt;T&gt; type,
      final ProcessingPipeline pipeline) {
<span class="fc" id="L103">    final RowProcessor processor = pipeline.createAssembler();</span>
<span class="fc" id="L104">    groupRows.forEach(processor::processRow);</span>
<span class="fc" id="L105">    return processor.materialize(type);</span>
  }

  @Override
  public &lt;T&gt; Stream&lt;T&gt; stream(
      final Iterator&lt;? extends Map&lt;String, ?&gt;&gt; rows,
      final Class&lt;T&gt; type,
      final MappingConfig config) {
<span class="fc" id="L113">    final List&lt;Map&lt;String, ?&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L114">    rows.forEachRemaining(list::add);</span>
<span class="fc" id="L115">    return convertAll(list, type, config).stream();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>