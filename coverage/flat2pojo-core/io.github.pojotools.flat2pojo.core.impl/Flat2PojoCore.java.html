<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Flat2PojoCore.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">flat2pojo-coverage</a> &gt; <a href="../index.html" class="el_bundle">flat2pojo-core</a> &gt; <a href="index.source.html" class="el_package">io.github.pojotools.flat2pojo.core.impl</a> &gt; <span class="el_source">Flat2PojoCore.java</span></div><h1>Flat2PojoCore.java</h1><pre class="source lang-java linenums">package io.github.pojotools.flat2pojo.core.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import io.github.pojotools.flat2pojo.core.api.Flat2Pojo;
import io.github.pojotools.flat2pojo.core.config.ListHierarchyCache;
import io.github.pojotools.flat2pojo.core.config.MappingConfig;
import io.github.pojotools.flat2pojo.core.config.MappingConfigLoader;
import io.github.pojotools.flat2pojo.core.engine.GroupingEngine;
import io.github.pojotools.flat2pojo.core.engine.ValueTransformer;
import io.github.pojotools.flat2pojo.core.util.PathResolver;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Stream;

public final class Flat2PojoCore implements Flat2Pojo {
  private final ObjectMapper objectMapper;

<span class="fc" id="L21">  public Flat2PojoCore(ObjectMapper objectMapper) {</span>
<span class="fc" id="L22">    this.objectMapper = objectMapper;</span>
<span class="fc" id="L23">  }</span>

  @Override
  public &lt;T&gt; Optional&lt;T&gt; convertOptional(
      Map&lt;String, ?&gt; flatRow, Class&lt;T&gt; type, MappingConfig config) {
<span class="nc" id="L28">    List&lt;T&gt; all = convertAll(List.of(flatRow), type, config);</span>
<span class="nc bnc" id="L29" title="All 2 branches missed.">    return all.isEmpty() ? Optional.empty() : Optional.of(all.getFirst());</span>
  }

  /**
   * Converts flat key-value maps into structured POJOs using hierarchical list grouping.
   *
   * &lt;p&gt;Algorithm: Validate → Group by rootKeys → Process each group → Materialize to POJO
   *
   * @param rows flat key-value maps (e.g., from CSV, database JOIN results)
   * @param type target POJO class to convert to
   * @param config mapping configuration defining list rules, separators, conflict policies
   * @return list of structured POJOs, one per root group
   */
  @Override
  public &lt;T&gt; List&lt;T&gt; convertAll(
      final List&lt;? extends Map&lt;String, ?&gt;&gt; rows, final Class&lt;T&gt; type, final MappingConfig config) {
<span class="fc" id="L45">    MappingConfigLoader.validateHierarchy(config);</span>
<span class="fc" id="L46">    final ProcessingPipeline pipeline = buildProcessingPipeline(config);</span>

<span class="fc bfc" id="L48" title="All 2 branches covered.">    return config.rootKeys().isEmpty()</span>
<span class="fc" id="L49">        ? convertWithoutGrouping(rows, type, pipeline)</span>
<span class="fc" id="L50">        : convertWithGrouping(rows, type, config, pipeline);</span>
  }

  private ProcessingPipeline buildProcessingPipeline(final MappingConfig config) {
<span class="fc" id="L54">    final AssemblerDependencies dependencies = buildAssemblerDependencies(config);</span>
<span class="fc" id="L55">    final ProcessingContext context = buildProcessingContext(config);</span>
<span class="fc" id="L56">    return new ProcessingPipeline(dependencies, context);</span>
  }

  private ProcessingContext buildProcessingContext(final MappingConfig config) {
<span class="fc" id="L60">    final PathResolver pathResolver = new PathResolver(config.separator());</span>
<span class="fc" id="L61">    final ListHierarchyCache hierarchyCache = new ListHierarchyCache(config, pathResolver);</span>
<span class="fc" id="L62">    return new ProcessingContext(config, hierarchyCache, pathResolver);</span>
  }

  private AssemblerDependencies buildAssemblerDependencies(final MappingConfig config) {
<span class="fc" id="L66">    final GroupingEngine groupingEngine = new GroupingEngine(objectMapper, config);</span>
<span class="fc" id="L67">    final ValueTransformer valueTransformer = new ValueTransformer(objectMapper, config);</span>
<span class="fc" id="L68">    final ResultMaterializer materializer = new ResultMaterializer(objectMapper);</span>
<span class="fc" id="L69">    return new AssemblerDependencies(objectMapper, groupingEngine, valueTransformer, materializer);</span>
  }

  private &lt;T&gt; List&lt;T&gt; convertWithoutGrouping(
      final List&lt;? extends Map&lt;String, ?&gt;&gt; rows,
      final Class&lt;T&gt; type,
      final ProcessingPipeline pipeline) {
<span class="fc" id="L76">    final RowProcessor processor = pipeline.createAssembler();</span>
<span class="fc" id="L77">    rows.forEach(processor::processRow);</span>
<span class="fc" id="L78">    return List.of(processor.materialize(type));</span>
  }

  private &lt;T&gt; List&lt;T&gt; convertWithGrouping(
      final List&lt;? extends Map&lt;String, ?&gt;&gt; rows,
      final Class&lt;T&gt; type,
      final MappingConfig config,
      final ProcessingPipeline pipeline) {
<span class="fc" id="L86">    final Map&lt;Object, List&lt;Map&lt;String, ?&gt;&gt;&gt; rowGroups =</span>
<span class="fc" id="L87">        RootKeyGrouper.groupByRootKeys(rows, config.rootKeys());</span>
<span class="fc" id="L88">    final List&lt;T&gt; results = new ArrayList&lt;&gt;(rowGroups.size());</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">    for (final List&lt;Map&lt;String, ?&gt;&gt; groupRows : rowGroups.values()) {</span>
<span class="fc" id="L90">      results.add(processGroup(groupRows, type, pipeline));</span>
<span class="fc" id="L91">    }</span>
<span class="fc" id="L92">    return results;</span>
  }

  private &lt;T&gt; T processGroup(
      final List&lt;Map&lt;String, ?&gt;&gt; groupRows,
      final Class&lt;T&gt; type,
      final ProcessingPipeline pipeline) {
<span class="fc" id="L99">    final RowProcessor processor = pipeline.createAssembler();</span>
<span class="fc" id="L100">    groupRows.forEach(processor::processRow);</span>
<span class="fc" id="L101">    return processor.materialize(type);</span>
  }

  @Override
  public &lt;T&gt; Stream&lt;T&gt; stream(
      final Iterator&lt;? extends Map&lt;String, ?&gt;&gt; rows,
      final Class&lt;T&gt; type,
      final MappingConfig config) {
<span class="fc" id="L109">    final List&lt;Map&lt;String, ?&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L110">    rows.forEachRemaining(list::add);</span>
<span class="fc" id="L111">    return convertAll(list, type, config).stream();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>